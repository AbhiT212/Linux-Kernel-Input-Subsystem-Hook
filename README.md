# Linux-Kernel-Input-Subsystem-Hook
A Linux Kernel Module (LKM) that demonstrates interrupt handling by hooking into the keyboard notification chain to log raw scancodes for educational analysis

Overview

This repository contains a Loadable Kernel Module (LKM) designed to intercept and log hardware input events at the kernel level. By hooking into the Linux keyboard notification chain, the module captures raw scancodes in atomic context and writes them to the kernel ring buffer. A companion user-space daemon parses this telemetry data in real time.
Legal and Ethical Disclaimer

This software is provided strictly for educational, administrative, and academic research purposes. It is engineered to demonstrate Linux kernel subsystem interactions, interrupt handling, and cross-space data transfer methodologies. The author assumes no liability for unauthorized, malicious, or illegal use of this codebase.
System Architecture

The project architecture is divided into two operational domains:

    Kernel Space Component (shadow.c): A custom driver utilizing the notifier_block structure to subscribe to hardware-level KBD_KEYCODE events. It operates safely within atomic context, avoiding blocking operations while efficiently pushing raw scancodes to the kernel ring buffer via printk.

    User Space Daemon (decoder.py): A continuous monitoring script that tails the dmesg output. It isolates the specific kernel logs generated by the module, decodes the hardware scancodes using a defined QWERTY mapping dictionary, and reconstructs the input stream for analysis.

Prerequisites

To compile and execute this project, the target environment must meet the following requirements:

    Linux Kernel version 5.x or higher

    Root privileges (required for module insertion and kernel log access)

    build-essential package (GCC, Make)

    Linux Kernel Headers matching the active kernel version

    Python 3.x

Build and Deployment Instructions
1. Compile the Kernel Module

Navigate to the project directory and execute the makefile to compile the C source code against your current kernel headers.
Bash

make

2. Load the Module

Insert the compiled kernel object (.ko file) into the active kernel. This action requires administrative privileges.
Bash

sudo insmod shadow.ko

Verification: Run lsmod | grep shadow to confirm the module is active.
3. Initialize the Telemetry Decoder

In a separate terminal session, launch the user-space daemon to begin monitoring the ring buffer and decoding the intercepted scancodes.
Bash

python3 decoder.py

4. System Teardown

To halt hardware monitoring and remove the hook from the notification chain, unload the module from the kernel.
Bash

sudo rmmod shadow

Technical Concepts Demonstrated

    Atomic Context Management: Implementing safe execution paths within hardware interrupt handlers where sleeping or yielding is strictly prohibited.

    Kernel Notification Chains: Utilizing publisher-subscriber models within the Linux kernel to monitor core subsystem events without modifying source trees.

    Cross-Boundary Communication: Establishing unidirectional data flow from kernel space to user space leveraging standard circular logging buffers.
